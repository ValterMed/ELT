"""
Streamlit Dashboard for Air Pollution Analysis
Connects to PostgreSQL analytics_pollution and daily_aggregations_pollution tables
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import psycopg2
from psycopg2.extras import RealDictCursor
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================
# PAGE CONFIGURATION
# ============================================
st.set_page_config(
    page_title="Air Pollution Analysis Dashboard",
    page_icon="ðŸŒ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ============================================
# DATABASE CONNECTION
# ============================================

@st.cache_resource
def get_db_connection():
    """Create and cache database connection"""
    try:
        conn = psycopg2.connect(
            host="postgres",
            database="pollution_db",
            user="airflow",
            password="airflow",
            port=5432
        )
        logger.info("Connected to PostgreSQL")
        return conn
    except Exception as e:
        logger.error(f"Database connection error: {str(e)}")
        st.error(f"âŒ Cannot connect to database: {str(e)}")
        return None

def query_analytics_data(query, params=None):
    """Execute query and return dataframe"""
    try:
        conn = get_db_connection()
        if conn is None:
            return pd.DataFrame()
        
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute(query, params)
        data = cursor.fetchall()
        cursor.close()
        
        if data:
            return pd.DataFrame(data)
        return pd.DataFrame()
    except Exception as e:
        logger.error(f"Query error: {str(e)}")
        st.error(f"Query failed: {str(e)}")
        return pd.DataFrame()

# ============================================
# DASHBOARD LAYOUT
# ============================================

st.title("ðŸŒ Air Pollution Analysis Dashboard")
st.markdown("**ELT Pipeline Output** - Real-time Air Quality Monitoring")

# Sidebar filters
st.sidebar.header("ðŸ“Š Filters")

# Date range selector
date_range = st.sidebar.date_input(
    "Select Date Range",
    value=(datetime.now() - timedelta(days=7), datetime.now()),
    max_value=datetime.now()
)

# Station selector
with st.spinner("Loading stations..."):
    stations_query = "SELECT DISTINCT station_code, station_name FROM analytics_pollution ORDER BY station_name"
    stations_df = query_analytics_data(stations_query)
    
    if not stations_df.empty:
        station_options = {
            f"{row['station_name']} ({row['station_code']})": row['station_code']
            for _, row in stations_df.iterrows()
        }
        selected_station_display = st.sidebar.selectbox(
            "Select Station",
            options=list(station_options.keys()) + ["All Stations"],
            index=len(station_options)
        )
        selected_station = station_options.get(selected_station_display) if selected_station_display != "All Stations" else None
    else:
        st.warning("âš ï¸ No station data available yet. Run the Airflow DAG to populate data.")
        selected_station = None

# Pollution level filter
pollution_categories = st.sidebar.multiselect(
    "Filter by Air Quality",
    options=['Good', 'Moderate', 'Unhealthy for Sensitive Groups', 'Unhealthy', 'Very Unhealthy', 'Hazardous'],
    default=['Good', 'Moderate', 'Unhealthy for Sensitive Groups', 'Unhealthy', 'Very Unhealthy', 'Hazardous']
)

st.sidebar.markdown("---")
st.sidebar.markdown("### â„¹ï¸ About This Dashboard")
st.sidebar.info(
    "This dashboard displays transformed data from the **analytics_pollution table** "
    "generated by the ELT pipeline. Data is automatically refreshed when the Airflow DAG runs."
)

# ============================================
# KEY METRICS
# ============================================

st.markdown("## ðŸ“ˆ Key Metrics")

col1, col2, col3, col4 = st.columns(4)

# Build query for KPIs
kpi_query = """
    SELECT 
        COUNT(*) as total_records,
        ROUND(AVG(air_quality_index)::numeric, 2) as avg_aqi,
        ROUND(MAX(air_quality_index)::numeric, 2) as max_aqi,
        ROUND(AVG(pm25_clean)::numeric, 2) as avg_pm25
    FROM analytics_pollution
    WHERE measurement_date >= %s 
    AND measurement_date <= %s
"""

params = [date_range[0], date_range[1]]

if selected_station:
    kpi_query += " AND station_code = %s"
    params.append(selected_station)

if pollution_categories:
    placeholders = ','.join(['%s'] * len(pollution_categories))
    kpi_query += f" AND pollution_category IN ({placeholders})"
    params.extend(pollution_categories)

kpi_df = query_analytics_data(kpi_query, params)

if not kpi_df.empty and len(kpi_df) > 0:
    row = kpi_df.iloc[0]
    
    with col1:
        st.metric("Total Records", f"{row.get('total_records', 0):,}")
    
    with col2:
        avg_aqi = row.get('avg_aqi', 0)
        st.metric("Average AQI", f"{avg_aqi:.2f}")
    
    with col3:
        max_aqi = row.get('max_aqi', 0)
        st.metric("Max AQI", f"{max_aqi:.2f}")
    
    with col4:
        avg_pm25 = row.get('avg_pm25', 0)
        st.metric("Avg PM2.5 (Î¼g/mÂ³)", f"{avg_pm25:.2f}")
else:
    col1.metric("Total Records", "0")
    col2.metric("Average AQI", "N/A")
    col3.metric("Max AQI", "N/A")
    col4.metric("Avg PM2.5 (Î¼g/mÂ³)", "N/A")

st.markdown("---")

# ============================================
# CHARTS
# ============================================

st.markdown("## ðŸ“Š Visualizations")

# Chart 1: PM2.5 Time Series
st.markdown("### PM2.5 Concentration Over Time")

timeseries_query = """
    SELECT 
        measurement_date,
        ROUND(AVG(pm25_clean)::numeric, 2) as avg_pm25,
        ROUND(MAX(pm25_clean)::numeric, 2) as max_pm25,
        ROUND(MIN(pm25_clean)::numeric, 2) as min_pm25,
        station_code
    FROM analytics_pollution
    WHERE measurement_date >= %s 
    AND measurement_date <= %s
"""

params = [date_range[0], date_range[1]]

if selected_station:
    timeseries_query += " AND station_code = %s"
    params.append(selected_station)

timeseries_query += " GROUP BY measurement_date, station_code ORDER BY measurement_date"

timeseries_df = query_analytics_data(timeseries_query, params)

if not timeseries_df.empty:
    fig_pm25 = px.line(
        timeseries_df,
        x='measurement_date',
        y=['avg_pm25', 'max_pm25', 'min_pm25'],
        title='PM2.5 Trends',
        labels={'measurement_date': 'Date', 'value': 'Concentration (Î¼g/mÂ³)'},
        color_discrete_map={
            'avg_pm25': '#1f77b4',
            'max_pm25': '#ff7f0e',
            'min_pm25': '#2ca02c'
        }
    )
    fig_pm25.update_layout(hovermode='x unified', height=400)
    st.plotly_chart(fig_pm25, use_container_width=True)
else:
    st.info("No data available for the selected filters")

# Chart 2: Pollutant Comparison
st.markdown("### Pollutant Comparison")

col_left, col_right = st.columns(2)

# Average pollutants by station
pollutants_query = """
    SELECT 
        station_name,
        ROUND(AVG(so2_clean)::numeric, 2) as SO2,
        ROUND(AVG(no2_clean)::numeric, 2) as NO2,
        ROUND(AVG(o3_clean)::numeric, 2) as O3,
        ROUND(AVG(pm10_clean)::numeric, 2) as PM10,
        ROUND(AVG(pm25_clean)::numeric, 2) as PM2.5
    FROM analytics_pollution
    WHERE measurement_date >= %s 
    AND measurement_date <= %s
"""

params = [date_range[0], date_range[1]]

if selected_station:
    pollutants_query += " AND station_code = %s"
    params.append(selected_station)

pollutants_query += " GROUP BY station_name"

pollutants_df = query_analytics_data(pollutants_query, params)

if not pollutants_df.empty:
    # Melt for easier plotting
    pollutants_melted = pollutants_df.melt(
        id_vars=['station_name'],
        var_name='Pollutant',
        value_name='Concentration'
    )
    
    fig_pollutants = px.bar(
        pollutants_melted,
        x='station_name',
        y='Concentration',
        color='Pollutant',
        title='Average Pollutant Levels by Station',
        barmode='group',
        height=400
    )
    col_left.plotly_chart(fig_pollutants, use_container_width=True)
else:
    col_left.info("No pollutant data available")

# Air Quality Distribution
quality_query = """
    SELECT 
        pollution_category,
        COUNT(*) as count
    FROM analytics_pollution
    WHERE measurement_date >= %s 
    AND measurement_date <= %s
"""

params = [date_range[0], date_range[1]]

if selected_station:
    quality_query += " AND station_code = %s"
    params.append(selected_station)

if pollution_categories:
    placeholders = ','.join(['%s'] * len(pollution_categories))
    quality_query += f" AND pollution_category IN ({placeholders})"
    params.extend(pollution_categories)

quality_query += " GROUP BY pollution_category"

quality_df = query_analytics_data(quality_query, params)

if not quality_df.empty:
    fig_quality = px.pie(
        quality_df,
        values='count',
        names='pollution_category',
        title='Air Quality Distribution',
        height=400,
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    col_right.plotly_chart(fig_quality, use_container_width=True)
else:
    col_right.info("No quality distribution data")

# ============================================
# DETAILED DATA TABLE
# ============================================

st.markdown("---")
st.markdown("## ðŸ“‹ Detailed Data")

detail_query = """
    SELECT 
        measurement_date,
        station_name,
        station_code,
        ROUND(so2_clean::numeric, 2) as SO2,
        ROUND(no2_clean::numeric, 2) as NO2,
        ROUND(o3_clean::numeric, 2) as O3,
        ROUND(pm10_clean::numeric, 2) as PM10,
        ROUND(pm25_clean::numeric, 2) as PM2.5,
        ROUND(air_quality_index::numeric, 2) as AQI,
        pollution_category,
        data_quality_flag
    FROM analytics_pollution
    WHERE measurement_date >= %s 
    AND measurement_date <= %s
"""

params = [date_range[0], date_range[1]]

if selected_station:
    detail_query += " AND station_code = %s"
    params.append(selected_station)

if pollution_categories:
    placeholders = ','.join(['%s'] * len(pollution_categories))
    detail_query += f" AND pollution_category IN ({placeholders})"
    params.extend(pollution_categories)

detail_query += " ORDER BY measurement_date DESC LIMIT 500"

detail_df = query_analytics_data(detail_query, params)

if not detail_df.empty:
    st.dataframe(detail_df, use_container_width=True, height=400)
    
    # Download button
    csv = detail_df.to_csv(index=False)
    st.download_button(
        label="ðŸ“¥ Download Data as CSV",
        data=csv,
        file_name=f"pollution_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
        mime="text/csv"
    )
else:
    st.info("No detailed data available for the selected date range and filters")

# ============================================
# FOOTER & INSIGHTS
# ============================================

st.markdown("---")
st.markdown("## ðŸ” Key Insights")

insights_col1, insights_col2 = st.columns(2)

with insights_col1:
    st.markdown("""
    ### ðŸŒ± Environmental Impact
    - **PM2.5**: Small particulates that penetrate deep into lungs
    - **NO2**: Causes respiratory issues and forms secondary pollutants
    - **O3**: Ground-level ozone damages respiratory system
    
    ### ðŸ‘¥ Who Benefits?
    - **Urban Planners**: Optimize traffic and industrial zones
    - **Health Officials**: Monitor population health impacts
    - **Policy Makers**: Create environmental regulations
    - **General Public**: Track daily air quality for health decisions
    """)

with insights_col2:
    st.markdown("""
    ### ðŸ“Š Air Quality Categories (AQI)
    - **1 - Good** (PM2.5 â‰¤ 12): Safe for all activities
    - **2 - Moderate** (â‰¤ 35.4): Acceptable for most
    - **3 - Unhealthy for Sensitive**: Groups at risk should limit exposure
    - **4 - Unhealthy** (â‰¤ 150.4): Everyone begins to experience effects
    - **5 - Very Unhealthy** (â‰¤ 250.4): Health alert condition
    - **6 - Hazardous** (> 250.4): Everyone should avoid outdoor activity
    """)

st.markdown("---")
st.markdown("""
**Data Source**: Analytics table from ELT Pipeline  
**Last Updated**: Real-time from PostgreSQL  
**Dashboard**: Built with Streamlit
""")